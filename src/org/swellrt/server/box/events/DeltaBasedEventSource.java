package org.swellrt.server.box.events;

import com.google.inject.Inject;

import org.swellrt.model.ReadableString;
import org.swellrt.model.ReadableType;
import org.swellrt.model.generic.ListType;
import org.swellrt.model.generic.MapType;
import org.swellrt.model.generic.Model;
import org.swellrt.model.shared.ModelUtils;
import org.swellrt.model.unmutable.UnmutableModel;
import org.swellrt.server.box.events.Event.Builder;
import org.swellrt.server.box.events.Event.Type;
import org.waveprotocol.box.common.DeltaSequence;
import org.waveprotocol.box.server.waveserver.WaveBus.Subscriber;
import org.waveprotocol.wave.model.document.Doc;
import org.waveprotocol.wave.model.document.Document;
import org.waveprotocol.wave.model.document.operation.AnnotationBoundaryMap;
import org.waveprotocol.wave.model.document.operation.Attributes;
import org.waveprotocol.wave.model.document.operation.AttributesUpdate;
import org.waveprotocol.wave.model.document.operation.DocOp;
import org.waveprotocol.wave.model.document.operation.DocOpCursor;
import org.waveprotocol.wave.model.document.util.DocHelper;
import org.waveprotocol.wave.model.id.ModernIdSerialiser;
import org.waveprotocol.wave.model.id.WaveletName;
import org.waveprotocol.wave.model.operation.wave.AddParticipant;
import org.waveprotocol.wave.model.operation.wave.BlipContentOperation;
import org.waveprotocol.wave.model.operation.wave.BlipOperation;
import org.waveprotocol.wave.model.operation.wave.RemoveParticipant;
import org.waveprotocol.wave.model.operation.wave.TransformedWaveletDelta;
import org.waveprotocol.wave.model.operation.wave.WaveletBlipOperation;
import org.waveprotocol.wave.model.operation.wave.WaveletOperation;
import org.waveprotocol.wave.model.version.HashedVersion;
import org.waveprotocol.wave.model.wave.data.ReadableBlipData;
import org.waveprotocol.wave.model.wave.data.ReadableWaveletData;
import org.waveprotocol.wave.util.logging.Log;

import java.util.HashMap;
import java.util.Map;


/**
 * A processor which generates Data Model Events interpreting Document
 * Operations received from the Wave Bus.
 *
 * Document operations sequences are generated by mutations in a swellrt data
 * Model.
 *
 * Generated events can include context data from the mutated model according a
 * set of provided paths by an event processor configurator.
 *
 *
 *
 * @author pablojan@gmail.com (Pablo Ojanguren)
 *
 */
public class DeltaBasedEventSource implements Subscriber {

  private static final Log LOG = Log.get(DeltaBasedEventSource.class);


  /**
   * A DocOp cursor that generates data model events. The same cursor must be
   * used to process all the ops in the same delta.
   *
   * For now this cursor is used to generate events for maps, lists and docs but
   * it might be clearer to have separated cursor by data type according the
   * blip id.
   *
   * @author pablojan@gmail.com (Pablo Ojanguren)
   *
   */
  private class DocOpToEventCursor implements DocOpCursor {

    static final String CREATE_ELEMENT = "create";
    static final String DELETE_ELEMENT = "delete";

    String lastMapDocOp = null;
    String lastMapDocOpKey = null;
    String lastMapDocOpValue = null;

    /** The context of this op */
    ReadableWaveletData wavelet;

    /** The context of this op */
    UnmutableModel dataModel;

    /** An event builder */
    Event.Builder eventBuilder;

    /** The data model path of the object affected by the next op to process */
    String path;


    public void flushPendingOps() {
      if (lastMapDocOp != null) triggerLastMapDocOp();
    }

    protected void setLastMapDocOp(String op, String key, String value) {

      lastMapDocOp = op;
      lastMapDocOpKey = key;
      lastMapDocOpValue = value;

    }

    protected void triggerLastMapDocOp() {

      if (lastMapDocOp.equals(CREATE_ELEMENT)) {

        // TODO support new MAP_ENTRY_CREATED
        eventQueue.add(eventBuilder.build(Type.MAP_ENTRY_UPDATED, path + "." + lastMapDocOpKey));

      } else if (lastMapDocOp.equals(DELETE_ELEMENT)) {

        eventQueue.add(eventBuilder.build(Type.MAP_ENTRY_REMOVED, path + "." + lastMapDocOpKey));

      }

      setLastMapDocOp(null, null, null);

    }

    protected void triggerLastMapDocOpUpdate() {

      eventQueue.add(eventBuilder.build(Type.MAP_ENTRY_UPDATED, path + "." + lastMapDocOpKey));

      setLastMapDocOp(null, null, null);

    }

    /**
     * For map operations we need to check previous doc op to distiguish between
     * new, update or remove map ops.
     *
     * @param op
     * @param key
     * @param value
     */
    protected void processMapDocOp(String op, String key, String value) {

      // LOG.info("Map DocOp = [" + op + ":" + key + "]");

      // buffer op
      if (lastMapDocOp == null) {

        setLastMapDocOp(op, key, value);

      } else {

        if (lastMapDocOpKey.equals(key)) {

          // a map update is a sequence of startElement - endElement or
          // viceversa
          if (!lastMapDocOp.equals(op)) {

            triggerLastMapDocOpUpdate();

          } else {

            triggerLastMapDocOp();
            setLastMapDocOp(op, key, value);

          }


        } else {

          triggerLastMapDocOp();
          setLastMapDocOp(op, key, value);

        }


      }

    }


    public DocOpToEventCursor(ReadableWaveletData wavelet, UnmutableModel dataModel,
        Builder eventBuilder) {
      super();
      this.wavelet = wavelet;
      this.dataModel = dataModel;
      this.eventBuilder = eventBuilder;
    }

    public void setDocOpContext(String path) {
      this.path = path;
    }


    @Override
    public void annotationBoundary(AnnotationBoundaryMap map) {
    }

    @Override
    public void characters(String chars) {

      String blipId = eventBuilder.getBlipId();

      if (ModelUtils.isTextBlip(blipId)) {
        eventQueue.add(eventBuilder.buildDocChange(path, chars));
      }

    }

    @Override
    public void elementStart(String type, Attributes attrs) {

      String blipId = eventBuilder.getBlipId();

      //
      // Map Op
      //
      if (ModelUtils.isMapBlip(blipId) && type.equals(MapType.TAG_ENTRY)) {

        processMapDocOp(CREATE_ELEMENT, attrs.get(MapType.KEY_ATTR_NAME),
            attrs.get(MapType.VALUE_ATTR_NAME));

        return;
      }

      //
      // List Op
      //
      if (ModelUtils.isListBlip(blipId) && type.equals(ListType.TAG_LIST_ITEM)) {

        String ref = attrs.get(ListType.ATTR_LIST_ITEM_REF);

        // Look up context data in added containers
        if (ModelUtils.isContainerId(ref)) {

          if (wavelet.getDocumentIds().contains(ref)) {

            String refPath =
                ModelUtils.getMetadataPath(wavelet.getDocument(ref).getContent()
                    .getMutableDocument());

            eventQueue.add(eventBuilder.build(Type.LIST_ITEM_ADDED, path,
                evaluateContextData(dataModel, refPath, eventBuilder.getContextData())));
          }

        } else {

          // Just get the primitive value added to the list
          eventQueue.add(eventBuilder.build(Type.LIST_ITEM_ADDED, path,
              evaluateContextData(wavelet.getDocument(eventBuilder.getBlipId()), path, ref)));
        }

      }
    }


    @Override
    public void elementEnd() {
    }

    @Override
    public void retain(int itemCount) {
    }

    @Override
    public void deleteCharacters(String chars) {
      String blipId = eventBuilder.getBlipId();

      if (ModelUtils.isTextBlip(blipId)) {
        eventQueue.add(eventBuilder.buildDocChange(path, chars));
      }
    }

    @Override
    public void deleteElementStart(String type, Attributes attrs) {

      String blipId = eventBuilder.getBlipId();

      //
      // Map Op
      //
      if (ModelUtils.isMapBlip(blipId) && type.equals(MapType.TAG_ENTRY)) {

        String key = attrs.get(MapType.KEY_ATTR_NAME);
        String value = attrs.get(MapType.VALUE_ATTR_NAME);

        processMapDocOp(DELETE_ELEMENT, key, value);
        return;
      }

      //
      // List Op
      //
      if (type.equals(ListType.TAG_LIST_ITEM)) {
        eventQueue.add(eventBuilder.build(Type.LIST_ITEM_REMOVED, path));
      }

    }

    @Override
    public void deleteElementEnd() {
    }

    @Override
    public void replaceAttributes(Attributes oldAttrs, Attributes newAttrs) {
    }

    @Override
    public void updateAttributes(AttributesUpdate attrUpdate) {
    }

  }

  protected EventQueue eventQueue;

  @Inject
  public DeltaBasedEventSource(EventQueue eventQueue) {
    this.eventQueue = eventQueue;
  }

  protected String getWaveletApp(ReadableWaveletData wavelet) {
    Document docModelRoot =
        wavelet.getDocument(Model.DOC_MODEL_ROOT).getContent().getMutableDocument();
    Doc.E eltModel = DocHelper.getElementWithTagName(docModelRoot, Model.TAG_MODEL);
    return docModelRoot.getAttribute(eltModel, Model.ATTR_APP_METADATA);
  }

  protected String getWaveletDataType(ReadableWaveletData wavelet) {
    Document docModelRoot =
        wavelet.getDocument(Model.DOC_MODEL_ROOT).getContent().getMutableDocument();
    Doc.E eltModel = DocHelper.getElementWithTagName(docModelRoot, Model.TAG_MODEL);
    return docModelRoot.getAttribute(eltModel, Model.ATTR_TYPE_METADATA);
  }


  /**
   * Matches a expression against a parent path, then evaluate the expression
   * against the model to get the actual value.
   * 
   * Example:
   * 
   * if
   * 
   * opPath ["root.list.3"] contextData ["root.list.?.field"]
   * 
   * then
   * 
   * newContextData["root.list.?.field"] = valueOf("root.list.3.field")
   * 
   * if
   * 
   * opPath ["root.list.2.array.5"] contextData ["root.list.?.array.?.field"]
   * 
   * then
   * 
   * newContextData["root.list.?.array.?.field"] =
   * valueOf("root.list.2.array.5")
   * 
   * Returns a copy of the provided context data but including these new values.
   * 
   */
  protected Map<String, String> evaluateContextData(UnmutableModel dataModel, String opPath,
      Map<String, String> contextData) {

    Map<String, String> newContextData = new HashMap<String, String>(contextData);

    for (String key : contextData.keySet()) {

      String path = ExpressionParser.matchSubpath(key, opPath);

      if (path != null) {
        ReadableType value = dataModel.fromPath(path);
        if (value == null) {
          LOG.warning("Unable to get value from path " + path + " in "
              + ModernIdSerialiser.INSTANCE.serialiseWaveId(dataModel.getWaveId()));
          break;
        }
        ReadableString strValue = value.asString();
        if (strValue != null) newContextData.put(key, strValue.getValue());
      }
    }

    return newContextData;
  }

  /**
   * Generate a new context data map with a single value referenced by the the
   * containerPath and the value on it referenced as containerValueRef.
   *
   * if
   *
   *  containerPath = root.list
   *  containerValueRef = str+3
   *
   * then
   *
   *  newContextData["root.list.?"] = (value of str+3 in the blip)
   *
   */
  protected Map<String, String> evaluateContextData(ReadableBlipData containerBlip,
      String containerPath,
      String containerValueRef) {

    Map<String, String> newContextData = new HashMap<String, String>();

    newContextData.put(containerPath + ".?",
        ModelUtils.getContainerValue(containerBlip, containerValueRef));

    return newContextData;
  }


  /**
   * Extract primitive values from the provided data model matching the paths
   * provided as keys of the context data map, and put values back to it.
   *
   * Paths with wildcards are ignored, they should be evaluated on specific.
   *
   * @param dataModel
   * @param contextData
   */
  protected void populateContextData(UnmutableModel dataModel, Map<String, String> contextData) {

    for (String path : contextData.keySet()) {
      if (!path.contains("?")) {
        ReadableType value = dataModel.fromPath(path);
        if (value != null && value.asString() != null) {
          contextData.put(path, value.asString().getValue());
        }

      }
    }
  }


  /**
   * Generate an empty map of paths to fill in with actual values of the updated
   * model.
   *
   * Paths not depending on event, no support list transversing: root.map.key
   * Paths including list wildcards are matching agains the values changed in
   * the add list event.
   *
   * @param app
   * @param dataType
   * @return
   */
  protected Map<String, String> initializeContextData(String app, String dataType) {

    Map<String, String> emptyContextData = new HashMap<String, String>();

    for (String p : eventQueue.getExpressionPaths(app, dataType)) {
      emptyContextData.put(p, null);
    }

    return emptyContextData;

  }

  @Override
  public void waveletUpdate(ReadableWaveletData wavelet, DeltaSequence deltas) {

    // This only applies to SwellRT data model wavelets
    if (!wavelet.getWaveletId().getId().equals(Model.WAVELET_SWELL_ROOT)) return;

    String app = getWaveletApp(wavelet);
    String dataType = getWaveletDataType(wavelet);

    // Only process deltas if there are event rules for this app and data type
    if (!eventQueue.hasEvents(app, dataType)) return;

    UnmutableModel dataModel = null;
    Map<String, String> contextData = initializeContextData(app, dataType);

    // Avoid to generate the tree data model if no context data is required
    if (!contextData.isEmpty()) {
      dataModel = UnmutableModel.create(wavelet);
      populateContextData(dataModel, contextData);
    }

    Event.Builder eventBuilder =
        new Event.Builder().app(app).dataType(dataType).contextData(contextData)
            .waveId(wavelet.getWaveId()).waveletId(wavelet.getWaveletId());


    for (TransformedWaveletDelta delta : deltas) {

      eventBuilder.deltaVersion(delta.getResultingVersion()).author(delta.getAuthor().getAddress())
          .timestamp(delta.getApplicationTimestamp());

      DocOpToEventCursor cursor = new DocOpToEventCursor(wavelet, dataModel, eventBuilder);

      for (WaveletOperation op : delta) {

        if (op instanceof AddParticipant) {

          eventQueue.add(eventBuilder.buildAddParticipant(((AddParticipant) op).getParticipantId()));
        }

        if (op instanceof RemoveParticipant) {
          eventQueue.add(eventBuilder.buildRemoveParticipant(((RemoveParticipant) op)
              .getParticipantId()));
        }

        if (op instanceof WaveletBlipOperation) {

          WaveletBlipOperation wbop = (WaveletBlipOperation) op;
          BlipOperation bop = wbop.getBlipOp();

          ReadableBlipData blipData = wavelet.getDocument(wbop.getBlipId());

          String path = "";
          if (ModelUtils.isTextBlip(wbop.getBlipId())) {
            // TODO get path of text objects from a suitable metadata attribute
            // on <body> tag ?
          } else {
            path = ModelUtils.getMetadataPath(blipData.getContent().getMutableDocument());
          }


          eventBuilder.blipId(blipData.getId());

          if (bop instanceof BlipContentOperation) {

            BlipContentOperation bcop = (BlipContentOperation) bop;
            DocOp docOp = bcop.getContentOp();

            // Set specific contex data for this doc op.
            cursor.setDocOpContext(path);
            docOp.apply(cursor);

          }

        }
      }
      // Remove pending deletion events
      cursor.flushPendingOps();
    }

  }

  @Override
  public void waveletCommitted(WaveletName waveletName, HashedVersion version) {

    // For now, we ignore this

  }


}
